
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gnampfelix/pub/connection.go (77.5%)</option>
				
				<option value="file1">github.com/gnampfelix/pub/message.go (71.4%)</option>
				
				<option value="file2">github.com/gnampfelix/pub/messenger.go (80.0%)</option>
				
				<option value="file3">github.com/gnampfelix/pub/publisher.go (72.7%)</option>
				
				<option value="file4">github.com/gnampfelix/pub/subscriber.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package pub

import (
        "bufio"
        "bytes"
        "errors"
        "io"
        "net"
        "net/textproto"
        "os"
)

const (
        MESSAGE_PREFIX    = 20
        MESSAGE_TAG       = 201
        MESSAGE_LINE      = 202
        MESSAGE_END       = 203
        STRING            = 301
        FILE_PREFIX       = 40
        FILE_START        = 401
        FILE_END          = 403
        FILE_LINE         = 402
        STREAM_START      = 501
        STREAM_LINE       = 502
        STREAM_END        = 503
        MESSAGE_END_TEXT  = "END MESSAGE"
        FILE_START_TEXT   = "START FILE"
        FILE_END_TEXT     = "END FILE"
        STREAM_START_TEXT = "START STREAM"
        STREAM_END_TEXT   = "END STREAM"
)

//        Connection can be used to transfer items over the network. A Connection can
//        transfer a string, a Message or a file. Furthermore, you can stil stream
//        over a Connection. All items are treated as lines or collections of lines
//        (according to POSIX, all lines must end with \n). For example, if a file is to
//        be send that doesn't end "correctly" with \n, the \n is added on the receiving side.
//        The resulting file will have a \n at the end.
type Connection interface {
        SendMessage(message Message) error
        SendString(message string) error
        SendAndCloseFile(file *os.File) error
        ReceiveMessageWithTag(tag string) (Message, error)
        ReceiveMessage() (Message, error)
        ReceiveString() (string, error)
        ReceiveFile(filename string) (*os.File, error)
        StartStream() error
        StopStream() error
        io.ReadWriteCloser
}

func NewConnection(conn net.Conn) Connection <span class="cov8" title="1">{
        return &amp;connection{conn: textproto.NewConn(conn), readBuffer: bytes.NewBuffer(make([]byte, 0))}
}</span>

type connection struct {
        conn        *textproto.Conn
        readBuffer  *bytes.Buffer
        isStreaming bool
}

func (c *connection) SendMessage(message Message) error <span class="cov8" title="1">{
        if c.isStreaming </span><span class="cov0" title="0">{
                return errors.New("can't send message when streaming")
        }</span>
        <span class="cov8" title="1">message.Close()
        tag := message.Tag()
        //TODO: Add split for tag if tag contains \n
        err := c.conn.PrintfLine("%d %s", MESSAGE_TAG, tag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">scanner := bufio.NewScanner(message)
        for scanner.Scan() </span><span class="cov8" title="1">{
                err = c.conn.PrintfLine("%d %s", MESSAGE_LINE, scanner.Text())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">err = c.conn.PrintfLine("%d %s", MESSAGE_END, MESSAGE_END_TEXT)
        return err</span>
}

func (c *connection) SendString(message string) error <span class="cov8" title="1">{
        if c.isStreaming </span><span class="cov0" title="0">{
                return errors.New("can't send string when streaming")
        }</span>
        //TODO: Add split for string if string contains \n
        <span class="cov8" title="1">return c.conn.PrintfLine("%d %s", STRING, message)</span>
}

func (c *connection) SendAndCloseFile(file *os.File) error <span class="cov8" title="1">{
        if c.isStreaming </span><span class="cov0" title="0">{
                return errors.New("can't send file when streaming")
        }</span>
        <span class="cov8" title="1">err := c.conn.PrintfLine("%d %s", FILE_START, FILE_START_TEXT)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov8" title="1">{
                err = c.conn.PrintfLine("%d %s", FILE_LINE, scanner.Text())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">file.Close()
        return c.conn.PrintfLine("%d %s", FILE_END, FILE_END_TEXT)</span>
}

func (c *connection) ReceiveMessageWithTag(tag string) (Message, error) <span class="cov8" title="1">{
        if c.isStreaming </span><span class="cov0" title="0">{
                return nil, errors.New("can't receive message when streaming")
        }</span>
        <span class="cov8" title="1">_, receivedTag, err := c.conn.ReadCodeLine(MESSAGE_TAG)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if receivedTag != tag </span><span class="cov8" title="1">{
                return nil, errors.New("the received tag didn't match the expected tag")
        }</span>

        <span class="cov8" title="1">message := NewMessage(tag)
        for </span><span class="cov8" title="1">{
                currentCode, currentLine, err := c.conn.ReadCodeLine(MESSAGE_PREFIX)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">if currentCode == MESSAGE_END </span><span class="cov8" title="1">{
                        return message, nil
                }</span><span class="cov8" title="1"> else if currentCode == MESSAGE_LINE </span><span class="cov8" title="1">{
                        message.Write([]byte(currentLine + "\n"))
                }</span><span class="cov0" title="0"> else {
                        return message, errors.New("can't read multiple tag lines")
                }</span>
        }
        <span class="cov0" title="0">return message, err</span>
}

func (c *connection) ReceiveMessage() (Message, error) <span class="cov8" title="1">{
        if c.isStreaming </span><span class="cov0" title="0">{
                return nil, errors.New("can't receive message when streaming")
        }</span>
        <span class="cov8" title="1">_, tag, err := c.conn.ReadCodeLine(MESSAGE_TAG)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">message := NewMessage(tag)
        for </span><span class="cov8" title="1">{
                currentCode, currentLine, err := c.conn.ReadCodeLine(MESSAGE_PREFIX)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">if currentCode == MESSAGE_END </span><span class="cov8" title="1">{
                        return message, nil
                }</span><span class="cov8" title="1"> else if currentCode == MESSAGE_LINE </span><span class="cov8" title="1">{
                        message.Write([]byte(currentLine + "\n"))
                }</span><span class="cov0" title="0"> else {
                        return message, errors.New("can't read multiple tag lines")
                }</span>
        }
        <span class="cov0" title="0">return message, err</span>
}

func (c *connection) ReceiveString() (string, error) <span class="cov8" title="1">{
        if c.isStreaming </span><span class="cov0" title="0">{
                return "", errors.New("can't receive string when streaming")
        }</span>
        <span class="cov8" title="1">_, result, err := c.conn.ReadCodeLine(STRING)
        return result, err</span>
}

func (c *connection) ReceiveFile(filename string) (*os.File, error) <span class="cov8" title="1">{
        if c.isStreaming </span><span class="cov0" title="0">{
                return nil, errors.New("can't receive file when streaming")
        }</span>
        <span class="cov8" title="1">file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_, _, err = c.conn.ReadCodeLine(FILE_START)
        if err != nil </span><span class="cov0" title="0">{
                return file, errors.New("no " + FILE_START_TEXT + " found")
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                code, line, err := c.conn.ReadCodeLine(FILE_PREFIX)
                if err != nil </span><span class="cov0" title="0">{
                        return file, err
                }</span>
                <span class="cov8" title="1">if code == FILE_LINE </span><span class="cov8" title="1">{
                        _, err = file.WriteString(line + "\n")
                        if err != nil </span><span class="cov0" title="0">{
                                return file, err
                        }</span>
                }<span class="cov8" title="1"> else if code == FILE_END </span><span class="cov8" title="1">{
                        file.Sync()
                        file.Seek(0, 0)
                        return file, nil
                }</span><span class="cov0" title="0"> else {
                        return file, errors.New("no valid file line received")
                }</span>
        }
}

func (c *connection) StartStream() error <span class="cov8" title="1">{
        if c.isStreaming </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">c.isStreaming = true
        err := c.conn.PrintfLine("%d %s", STREAM_START, STREAM_START_TEXT)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, _, err = c.conn.ReadCodeLine(STREAM_START)
        return err</span>
}

func (c *connection) StopStream() error <span class="cov8" title="1">{
        if !c.isStreaming </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">c.isStreaming = false
        err := c.conn.PrintfLine("%d %s", STREAM_END, STREAM_END_TEXT)
        return err</span>
}

func (c *connection) Write(p []byte) (int, error) <span class="cov8" title="1">{
        if !c.isStreaming </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov8" title="1">n := 0
        buffer := bytes.NewBuffer(p)
        scanner := bufio.NewScanner(buffer)
        for scanner.Scan() </span><span class="cov8" title="1">{
                err := c.conn.PrintfLine("%d %s", STREAM_LINE, scanner.Text())
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
                <span class="cov8" title="1">n += len(scanner.Bytes())</span>
        }
        <span class="cov8" title="1">return n, nil</span>
}

func (c *connection) Read(p []byte) (int, error) <span class="cov8" title="1">{
        if !c.isStreaming </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov8" title="1">max := len(p)

        n, err := c.readBuffer.Read(p)
        if err != nil </span><span class="cov8" title="1">{
                if err != io.EOF </span><span class="cov0" title="0">{
                        return n, err
                }</span>
        }

        <span class="cov8" title="1">for n &lt; max </span><span class="cov8" title="1">{
                _, message, err := c.conn.ReadCodeLine(STREAM_LINE)
                if err != nil </span><span class="cov8" title="1">{
                        if convErr, ok := err.(*textproto.Error); ok </span><span class="cov8" title="1">{
                                if convErr.Code == STREAM_END </span><span class="cov8" title="1">{
                                        c.isStreaming = false
                                }</span>
                        }
                        <span class="cov8" title="1">return n, err</span>
                }
                <span class="cov8" title="1">stringBytes := []byte(message + "\n")
                i := 0
                for ; n &lt; max &amp;&amp; i &lt; len(stringBytes); i++ </span><span class="cov8" title="1">{
                        p[n] = stringBytes[i]
                        n++
                }</span>
                <span class="cov8" title="1">if n &gt;= max </span><span class="cov8" title="1">{
                        tmpBuf := stringBytes[i:]
                        _, err = c.readBuffer.Write(tmpBuf)
                        return n, err
                }</span>

        }
        <span class="cov8" title="1">return n, nil</span>
}

func (c *connection) Close() error <span class="cov8" title="1">{
        return c.conn.Close()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package pub

import (
        "bytes"
        "io"
)

type Message interface {
        SetTag(tag string)
        Tag() string
        io.ReadWriteCloser
        Sender() string
        SetSender(sender string)
}

func NewMessage(tag string) Message <span class="cov8" title="1">{
        buffer := bytes.NewBuffer(make([]byte, 0))
        return &amp;simpleMessage{tag: tag,
                buffer:   buffer,
                isSealed: false,
        }
}</span>

type simpleMessage struct {
        tag      string
        buffer   *bytes.Buffer
        isSealed bool
        sender   string
}

func (s simpleMessage) Tag() string <span class="cov8" title="1">{
        return s.tag
}</span>

func (s *simpleMessage) SetTag(tag string) <span class="cov0" title="0">{
        s.tag = tag
}</span>

func (s *simpleMessage) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        n, err = s.buffer.Read(p)
        return n, err
}</span>

func (s *simpleMessage) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        if s.isSealed </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov8" title="1">n, err = s.buffer.Write(p)
        return n, err</span>
}

func (s *simpleMessage) Close() error <span class="cov8" title="1">{
        s.isSealed = true
        return nil
}</span>

func (s simpleMessage) Sender() string <span class="cov0" title="0">{
        return s.sender
}</span>
func (s *simpleMessage) SetSender(sender string) <span class="cov0" title="0">{
        s.sender = sender
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package pub

import (
        "errors"
        "net"
        "strconv"
)

//  A Messenger provides methods to simply connect two parties who want
//  to communicate. A Messenger can be used to transport a Publishers messages
//  over the network, but also to stream more complex data.
type Messenger interface {
        TalkTo(remote string) (Connection, error)
        ListenAt(port int, publisher Publisher) error
        StartConversation(key string) (Connection, bool)
        StopListening()
}

func NewMessenger() Messenger <span class="cov8" title="1">{
        return &amp;messenger{connections: make(map[string]Connection)}
}</span>

type messenger struct {
        port          int
        isTalking     bool
        isListening   bool
        stopListening bool
        connections   map[string]Connection //TODO: Mutex!
}

func (m *messenger) TalkTo(remote string) (Connection, error) <span class="cov8" title="1">{
        if m.isListening </span><span class="cov0" title="0">{
                return nil, errors.New("messenger can't listen and talk at the same time")
        }</span>
        <span class="cov8" title="1">conn, err := net.Dial("tcp", remote)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">m.isTalking = true
        return NewConnection(conn), nil</span>
}

func (m *messenger) ListenAt(port int, publisher Publisher) error <span class="cov8" title="1">{
        if m.isTalking </span><span class="cov0" title="0">{
                return errors.New("messenger can't listen and talk at the same time")
        }</span>
        <span class="cov8" title="1">m.isListening = true
        m.port = port
        listener, err := net.Listen("tcp", ":"+strconv.Itoa(port))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        conn, err := listener.Accept()
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">if m.stopListening </span><span class="cov8" title="1">{
                                conn.Close()
                                listener.Close()
                                return
                        }</span>
                        <span class="cov8" title="1">go m.handleNewConnection(conn, publisher)</span>
                }
        }()
        <span class="cov8" title="1">return nil</span>
}

func (m *messenger) handleNewConnection(conn net.Conn, publisher Publisher) <span class="cov8" title="1">{
        newConn := NewConnection(conn)
        connId, err := newConn.ReceiveString()
        if err != nil </span><span class="cov0" title="0">{
                newConn.Close()
                return
        }</span>
        <span class="cov8" title="1">notification := NewMessage(connId)
        notification.Write([]byte("READY"))
        publisher.Publish(notification)
        m.connections[connId] = newConn</span>
}

func (m *messenger) StartConversation(key string) (Connection, bool) <span class="cov8" title="1">{
        result, ok := m.connections[key]
        if ok </span><span class="cov8" title="1">{
                delete(m.connections, key)
        }</span>
        <span class="cov8" title="1">return result, ok</span>
}

func (m *messenger) StopListening() <span class="cov8" title="1">{
        if !m.isListening </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">m.stopListening = true
        conn, err := net.Dial("tcp", "localhost:"+strconv.Itoa(m.port))
        if err != nil </span><span class="cov0" title="0">{
                conn.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package pub

import (
        "io"
        "sync"
)

//  A Publisher can publish messages to different subscribers.
type Publisher interface {
        Publish(message Message)
        Subscribe(tag string, subCreater func() Subscriber) Subscriber
        Unsubscribe(tag string, subscriber Subscriber)
}

type publisher struct {
        subscribers map[string][]Subscriber
        sync.RWMutex
}

func New() Publisher <span class="cov8" title="1">{
        subs := make(map[string][]Subscriber)
        result := publisher{
                subscribers: subs,
        }
        return &amp;result
}</span>

func (p *publisher) Publish(message Message) <span class="cov8" title="1">{
        p.Lock()
        defer p.Unlock()
        message.Close()

        p.publishLocal(message.Tag(), message)
}</span>

func (p *publisher) publishLocal(tag string, payload io.Reader) <span class="cov8" title="1">{
        if subs, ok := p.subscribers[tag]; ok </span><span class="cov8" title="1">{
                messages := make([]Message, len(subs))
                writers := make([]io.Writer, len(subs))
                for i := range messages </span><span class="cov8" title="1">{
                        messages[i] = NewMessage(tag)
                        writers[i] = messages[i].(io.Writer)
                }</span>
                <span class="cov8" title="1">writer := io.MultiWriter(writers...)
                io.Copy(writer, payload)

                for i := range subs </span><span class="cov8" title="1">{
                        go subs[i].Receive(messages[i])
                }</span>
        }
}

func (p *publisher) Subscribe(tag string, subCreater func() Subscriber) Subscriber <span class="cov8" title="1">{
        p.Lock()
        defer p.Unlock()

        if _, ok := p.subscribers[tag]; !ok </span><span class="cov8" title="1">{
                p.subscribers[tag] = make([]Subscriber, 0)
        }</span>
        <span class="cov8" title="1">result := subCreater()
        p.subscribers[tag] = append(p.subscribers[tag], result)
        return result</span>
}

func (p *publisher) Unsubscribe(tag string, subscriber Subscriber) <span class="cov0" title="0">{
        subs, ok := p.subscribers[tag]
        subPosition := -1
        if ok </span><span class="cov0" title="0">{
                for i := range subs </span><span class="cov0" title="0">{
                        if subs[i] == subscriber </span><span class="cov0" title="0">{
                                subPosition = i
                                break</span>
                        }
                }
                <span class="cov0" title="0">if subPosition != -1 </span><span class="cov0" title="0">{
                        p.subscribers[tag] = append(subs[:subPosition], subs[subPosition+1:]...)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package pub

type Subscriber interface {
        WaitForMessage() Message
        Receive(message Message)
}

type simpleSubscriber struct {
        channel chan Message
}

func NewSubscriber() Subscriber <span class="cov8" title="1">{
        channel := make(chan Message, 4)
        return &amp;simpleSubscriber{channel}
}</span>

func (s *simpleSubscriber) WaitForMessage() Message <span class="cov8" title="1">{
        result := &lt;-s.channel
        return result
}</span>

func (s *simpleSubscriber) Receive(message Message) <span class="cov8" title="1">{
        s.channel &lt;- message
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
